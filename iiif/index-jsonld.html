<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<title>Viewer</title>
	
<style>

body {
	/* overflow: hidden; */
	margin: 0px;
	padding: 0px;
}

/* DIV enclosing the viewer */
#output {
}

/* IIIF viewer */
#viewport {
    background: #e5e5e5; /* Google Books */
    
    /*background: rgb(223,223,223);*/ /* PDF Expert */
    
    position:relative;
	overflow:hidden;
    padding:0px;
}

#surface {
	/* background: #e5e5e5; */
}

#allpages {
	position: absolute; 
}

#overflow-scrolling {
	position: relative; 
	overflow-x: auto; 
	overflow-y: scroll; 

	/* hand cursor */
  	cursor : -webkit-grab;
  	cursor : -moz-grab;
  	cursor : -o-grab;
  	cursor : grab;
}

.page {
	position: absolute; 
	left: 0px; 
}

.image {
	position: absolute; 
	left: 0px; 
	top: 0px; 
 	-webkit-user-select: none;
 	background:white;	
 	
 	/* border: 1px solid rgb(193,193,193); */ /* Google books */

	/*border: 1px solid rgb(149,149,149);*/ /* PDF Expert */
	/*box-shadow: 2px 2px 1px rgb(175,175,175);*/ /* PDF Expert */
 
 	/* Try and render image as b&w image */
 	/*
 	-webkit-filter: grayscale(100%) contrast(130%); 
 	*/
}

.lazy {
 /* -webkit-user-select: none; */ /* do we need this? */
}

/* layer that holds all the annotations that we display, e.g. selected text */
.annotation-layer {
	position: absolute; 
	left: 0px; 
	top: 0px; 	
	height:0px;
	width:0px;
	/* controls how visible the highlight is */		
	opacity: 0.3;
}

.annotation {
	position: absolute;
	background-color: yellow; 
}

.tick {
	position: absolute; 
	background-color: rgb(178, 196, 233); 
	width: 100%; 
	height: 5px; 
	cursor: pointer; 
	left: 0px;
}

</style>	
	
	<!-- Load the polyfill first. -->
	<!-- https://github.com/w3c/IntersectionObserver/tree/master/polyfill -->
	<script src="js/intersection-observer.js"></script>

	<!-- ejs for templating -->
	<script src="js/ejs.js"></script>
	
	<!-- jquery -->
    <script src="js/jquery-1.11.2.min.js" type="text/javascript"></script>
 


	<!-- <script src="m.json"></script> -->
	
	<script>
			//http://stackoverflow.com/a/25359264
		$.urlParam = function(name){
			var results = new RegExp('[\?&]' + name + '=([^&#]*)').exec(window.location.href);
			if (results==null){
			   return null;
			}
			else{
			   return results[1] || 0;
			}
		}   
	</script> 

	
<script>


//----------------------------------------------------------------------------------------
// http://stackoverflow.com/a/25715455
function isObject (item) {
  return (typeof item === "object" && !Array.isArray(item) && item !== null);
}

//----------------------------------------------------------------------------------------

</script>	

</head>
<body>

	<!-- <div id="info" style="float:right;width:200px;">info</div> -->

	<!-- this has the viewer -->
	<div id="output" style="width:100%;100%">
	</div>

	<script>
	
	var v = null;
	
	var data = null;
	
		// do we have a URL parameter?
		var url = $.urlParam('url');
		if (url) {
		   url = decodeURIComponent(url);
		   
		   console.log(url);
		   
		   $.getJSON(url, function(d) {

		   	data = d;
		   	
			// Create and setup the viewer
	
			v = new viewer_data(data, 'output');
	
			v.prepare();
	
			// Get window coordinates	
			var width = window.innerWidth;
			var height = window.innerHeight;
	
			v.calculate({ view_width: width, view_height: height });
		
			v.render();
	
			// add event handlers and observers
			v.actions();
	
			   	
		   	
		   	
		   	});
		}
	
	
	//------------------------------------------------------------------------------------

	/*
	
	Notes: 
	
	Lazy loading of images based on https://github.com/samdutton/simpl/tree/gh-pages/lazy
	
	For touch drag in browser see https://medium.com/creative-technology-concepts-code/native-browser-touch-drag-using-overflow-scroll-492dc92ac737
	
	For handling Chrome changing the cursor to text while dragging, see https://stackoverflow.com/a/47295954/9684
	
	For counting items in an object see http://stackoverflow.com/a/25715455
	
	Need a diagram of how the viewer works
	
	*/

	//------------------------------------------------------------------------------------
	// Initialise object to create viewer from IIIF manifest
	function viewer_data(manifest, element_id) {
	
		this.manifest = manifest;
		this.name = this.manifest.label;
	
		this.images = [];
		this.total_size = 0;
		this.page_space = 14; // 10 = Google Books
		this.page_width = 0;
		this.page_margin = 0;
				
		this.view_width = 0;
		this.view_height = 0;
		
		// tick mark display		
		this.tick_scale = 0;
		this.tick_left = 0;
		this.tick_space = 30;
		
		this.canvas_to_page_map = {};
		
		// annotations
		this.annotations = [];
		
		// Click and drag scrolling
		this.startx;
		this.starty;
		this.diffx;
		this.diffy;
		this.drag;
		
		// Store id of DOM element that encloses the viewer
		this.element_id = element_id;
		
		// Intersection observers
		this.io;
		this.io_info;
		
		// EJS template to render viewer
		this.template = `
		<div id="viewport" style="width: <%- data.view_width %>px;">
			<div id="overflow-scrolling" style="width: <%- data.view_width %>px; height: <%- data.view_height %>px;">
				<div id="surface" style="height: <%- data.total_size %>px;">
					<div id="allpages" style="left: <%- data.page_margin %>px;width: <%- data.page_width %>px; height: <%- data.total_size %>px;">
					
						<% for (var i in data.images)  { %>
							<div class="page" style="top: <%- data.images[i].scaled_top %>px;">
							
								<div id="<%- data.images[i].id %>" title="<%- data.images[i].name %>" class="image" style="width: <%- data.page_width %>px;height: <%- data.images[i].scaled_height %>px;">
									<img  class="lazy" width="<%- data.page_width %>" data-src="<%- data.images[i].url %>">
								</div> <!-- image -->
								
								<div id="<%- data.images[i].id %>-annotation" class="annotation-layer" >
								</div>
															
							</div> <!-- page -->
						
						<% } %>
						
					</div>	<!-- allpages -->			
				</div> <!-- surface -->
			</div> <!-- overflow-scrolling -->	
			
			<!-- ticks -->
			
			<div style="position:absolute;left:0px;top:0px;">

				<div id="ticks" style="position:absolute;left:<%- data.tick_left %>px;top:0px;width:15px;height:<%- data.view_height %>px;background:white;">

					<!-- debugging -->
					<% for (var i in data.ticks) { %>
						<div class="tick" style="top: <%- i %>px;" onclick="el.scrollTop=<%- data.ticks[i] %>">
						</div>
					<% } %>					

				</div><!-- ticks -->

			</div>
			
			
		</div> <!-- viewport -->				
	`;
		
	}
	
	//------------------------------------------------------------------------------------
	// get image size info, and generate a standard id for each image - page00000
	viewer_data.prototype.prepare = function() {
	
		for (var i in this.manifest.sequences[0].canvases) {

			var image = {};
		
			image.id = "page" + String("00000" + i).slice(-5);
		
			image.name   = this.manifest.sequences[0].canvases[i].label;		
			image.height = this.manifest.sequences[0].canvases[i].images[0].resource.height;
			image.width  = this.manifest.sequences[0].canvases[i].images[0].resource.width;
			image.url 	 = this.manifest.sequences[0].canvases[i].images[0].resource['@id'];
			
			image.canvas_scale = this.manifest.sequences[0].canvases[i].images[0].resource.width / this.manifest.sequences[0].canvases[i];
		
			this.images.push(image);
			
			// Map canvas id to index of page in viewer
			this.canvas_to_page_map[this.manifest.sequences[0].canvases[i]['@id']] = i;
		}
		
		console.log("canvas_to_page_map=" + JSON.stringify(this.canvas_to_page_map, null, 2));
	}
		
	//------------------------------------------------------------------------------------
	// calculate image sizes based on user-supplied viewer dimensions
	viewer_data.prototype.calculate = function(options) {

		// dimensions of viewer
		this.view_width = options.view_width;
		this.view_height = options.view_height;
		
		// place tick bar 
		this.tick_left = this.view_width - this.tick_space;
		
		// page displayed between left margin and tick bar, occupy 80% of that space
		//this.page_width = this.tick_left * 0.8;
		
		this.page_width = 685; // for now this is a constant so we don't recalculate layout of annotations
				
		// get left margin of page image
		this.page_margin = (this.tick_left - this.page_width)/2.0;
		
		// keep track of top of each page
		var page_top = 0;
		
		this.total_size = 0;
		
		for (var i in this.images) {
			this.images[i].scale = this.page_width / this.images[i].width;
			
			this.images[i].scaled_width = this.images[i].width * this.images[i].scale;
			this.images[i].scaled_height = this.images[i].height * this.images[i].scale;
		
			this.total_size += this.images[i].scaled_height;
			
			this.images[i].scaled_top = page_top;
			
			page_top += this.images[i].scaled_height + this.page_space;			
		}
		
		this.total_size += (this.images.length - 1) * this.page_space;
		
		// ticks are scaled to show complete range of document in viewer window (like a scroll bar)
		this.tick_scale = this.view_height / this.total_size;
		
		// store the tick location corresponding to the top of each page
		for (var i in this.images) {
			this.images[i].tick_top = this.images[i].scaled_top * this.tick_scale;
		}	

	}
	
	//------------------------------------------------------------------------------------
	// store an annotation
	viewer_data.prototype.add_annotation = function(annotation) {
		this.annotations.push(annotation);
	}
	
	//------------------------------------------------------------------------------------
	// add an annotation to the viewer
	viewer_data.prototype.display_annotations = function() {
		// clean any previous display
		
		var ticks = document.getElementById('ticks');
		ticks.innerHTML = '';
		
		for (var i in this.annotations) {
			this.display_one_annotation(this.annotations[i]);
		}

	}	
	
	//------------------------------------------------------------------------------------
	// add an annotation to the viewer
	viewer_data.prototype.display_one_annotation = function(annotation) {

		// canvas to paint on
		var canvas = null;
		
		// box to paint
		var box = null;
		
		// Annotation may have the target ("on") as a string (e.g., URL with fragment identifier)
		// or target is an object with a selector and a source ("full")		
		
		if (isObject(annotation.on)) {
			if (annotation.on.full) {
				canvas = annotation.on.full;
			}
			if (annotation.on.selector.value) {
				var match = annotation.on.selector.value.match(/xywh=(.*)/);
				if (match) {		
					box = match[1];	
				}			
			}					
		} else {
			var match = annotation.on.match(/(.*)#xywh=(.*)/);
			if (match) {		
				canvas = match[1];
				box = match[2];	
			}			
		}
	
		// to do: handle cases where annotation is not a box but rather simply a page
		if (canvas && box) {

			// which page in our viewer corresponds to this canvas?		
			var page_to_paint_on = this.canvas_to_page_map[canvas];

			console.log("canvas=" + canvas);
			console.log("page_to_paint_on=" + page_to_paint_on);

		
			// get canvas coordinates of annotation location from URL		
			var parts = box.split(/,/);
		
			var x = parseInt(parts[0]);
			var y = parseInt(parts[1]);
			var w = parseInt(parts[2]);
			var h = parseInt(parts[3]);
			
			
			// get canvas coordinates and normalise x,y,w,h to 
			var canvas_width  = this.manifest.sequences[0].canvases[page_to_paint_on].width;
			var canvas_height = this.manifest.sequences[0].canvases[page_to_paint_on].height;
			
			x /= canvas_width;
			w /= canvas_width;
			y /= canvas_height;
			h /= canvas_height;			
			
			// HTML to display, compute position relative to our HTML page size

			var html = '<div class="annotation" style="'
				+ 'left:' + Math.round(x * this.images[page_to_paint_on].scaled_width) + 'px;'
				+ 'top:' + Math.round(y * this.images[page_to_paint_on].scaled_height) + 'px;'
				+ 'width:' + Math.round(w * this.images[page_to_paint_on].scaled_width) + 'px;'
				+ 'height:' + Math.round(h * this.images[page_to_paint_on].scaled_height) + 'px;'
				+ '"></div>';
			
			// render	
			
			// get annotation layer for this page	
			var annotation_layer_id =  this.images[page_to_paint_on].id + '-annotation';				
			var layer = document.getElementById(annotation_layer_id);
			
			// add this annotation to the DOM
			layer.insertAdjacentHTML('beforeend', html);
			
			// where does tick mark appear?
			var tick_mark_pos = this.images[page_to_paint_on].tick_top + Math.round(y * this.images[page_to_paint_on].scaled_height * this.tick_scale);
		
			// where do we jump to when tick mark is clicked?
			var tick_mark_target = this.images[page_to_paint_on].scaled_top + Math.round(y * this.images[page_to_paint_on].scaled_height);
		
			// offset so target is clearly visible
			tick_mark_target = Math.max(this.images[page_to_paint_on].scaled_top, tick_mark_target - 100);
		
			// render
			var ticks = document.getElementById('ticks');
		
			html = '<div class="tick" style="top:' + tick_mark_pos + 'px;" onclick="document.querySelector(\'#overflow-scrolling\').scrollTop=' + tick_mark_target + '"></div>';
		
			ticks.insertAdjacentHTML('beforeend', html);
		}	
	}

	//------------------------------------------------------------------------------------
	viewer_data.prototype.actions = function() {
		if (!this.scroller) {
			this.scroller = document.querySelector('#overflow-scrolling');
		}
		
		// add event listeners
		this.scroller.addEventListener('mousedown', this.onMouseDown.bind(this));
		this.scroller.addEventListener('mousemove', this.onMouseMove.bind(this));
		this.scroller.addEventListener('mouseup', this.onMouseUp.bind(this));

		window.addEventListener('resize', this.resize.bind(this));
		
		// intersection observers for lazy loading of images and tracking which page is being displayed
		
		const images = document.querySelectorAll('img.lazy');
		
		const images_info = document.querySelectorAll('div.image');
				
		var options_lazyload = {
  			root: document.getElementById('overflow-scrolling'),
			  // rootMargin: top, right, bottom, left margins
			  // added to the bounding box of the root element (viewport if not defined)
			  // see https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver  				
  			rootMargin: '1000px 0px 1000px 0px',
  			
  			// threshold: how much of the target visible for the callback to be invoked
  			// includes padding, 1.0 means 100%  			
  			threshold: 0
  		};

		var options_info= {
  			root: document.getElementById('overflow-scrolling'),
  			 // match the page dimensions
  			rootMargin: '0px 0px 0px 0px',
  			
			// we want a big chunk of the page to be visible so we don't trigger events if just a bit appears  		  			
  			threshold: 0.5 
  		};
		
		if (window.IntersectionObserver) {
		
			// lazy loading of images
  			this.io = new IntersectionObserver(
				(function callback(entries) {
				  for (const entry of entries) {
					if (entry.isIntersecting) {
					  let lazyImage = entry.target;
					  if (!lazyImage.src && lazyImage.hasAttribute('data-src')) {
					  
						lazyImage.src = lazyImage.dataset.src;
					
						// presence of "width" is a flag that we will use an image CDN
						if (lazyImage.hasAttribute('width')) {
							lazyImage.src = 'http://exeg5le.cloudimg.io/s/width/' + this.page_width + '/' + lazyImage.src;
						}
					  }
					}
				  }
				}).bind(this) // bind(this) gives us access to "this"
				, 
				options_lazyload
			);
  			
  			// page information
   			this.io_info = new IntersectionObserver(
				function callback(entries) {
				  for (const entry of entries) {
					if (entry.isIntersecting) {
					  let item = entry.target;
					  if (item.hasAttribute('id')) {
		
						var html = '';
		
						if (item.hasAttribute('title')) {
							html += ' ' + item.title;
							html = item.title;
						}
		
						/*
						figure out how best to display what page we are on
						document.getElementById('info').innerHTML = html;
						*/
					  }
				  
					}
				  }
				}
				, 
				options_info
			);
  		}
		
		for (const image of images) {
		  if (window.IntersectionObserver) {
			this.io.observe(image);
		  } else {
			console.log('Intersection Observer not supported');
			image.src = image.getAttribute('data-src');
		  }
		}  		

		for (const image of images_info) {
		  if (window.IntersectionObserver) {
			this.io_info.observe(image);
			} 
		} 				
		
	}
	
	//------------------------------------------------------------------------------------
	viewer_data.prototype.onMouseDown = function(e) {
		if (!e) { e = window.event; }
		if (e.target && e.target.nodeName === 'IMG') {
			e.preventDefault();
		} else if (e.srcElement && e.srcElement.nodeName === 'IMG') {
			e.returnValue = false;
		}
		this.startx = e.clientX + this.scroller.scrollLeft;
		this.starty = e.clientY + this.scroller.scrollTop;
		this.diffx = 0;
		this.diffy = 0;
		this.drag = true;
	}

	//------------------------------------------------------------------------------------
	viewer_data.prototype.onMouseMove = function(e) {
		if (this.drag === true) {
		
			// https://stackoverflow.com/a/47295954/9684
			// ensure dragging cursor is not text cursor
			document.onselectstart = function(){ return false; }
	
			if (!e) { e = window.event; }
			this.diffy = (this.starty - (e.clientY + this.scroller.scrollTop));
			this.scroller.scrollTop += this.diffy;
		}
    }

	//------------------------------------------------------------------------------------
	viewer_data.prototype.onMouseUp = function(e) {
		if (!e) { e = window.event; }
		this.drag = false;
	
		// https://stackoverflow.com/a/47295954/9684
		document.onselectstart = function(){ return true; }  
		
		// make sure these variables will be in scope for the function animate()
		var el =  this.scroller;
		var diffy = this.diffy;
	
		var start = 1,
			animate = function () {
				var step = Math.sin(start);
				if (step <= 0) {
					window.cancelAnimationFrame(animate);
				} else {
					el.scrollTop += diffy * step;
					start -= 0.02;
					window.requestAnimationFrame(animate);
				}
			};
		animate();
    }

	//------------------------------------------------------------------------------------
	// resize viewer to match size of containing element
	viewer_data.prototype.resize = function() {
		
		var width = document.getElementById(this.element_id).clientWidth;
		var height = document.getElementById(this.element_id).clientHeight;
		
		//var width = window.innerWidth;
		//var height = window.innerHeight;		
		
		this.calculate({ view_width: width, view_height: height });
		
		var d = document.getElementById('viewport');		
		d.style.width= this.view_width + 'px';
		d.style.height= this.view_height + 'px';

		var s = document.getElementById('overflow-scrolling');		
		s.style.width= this.view_width + 'px';
		s.style.height= this.view_height + 'px';
		
		var t = document.getElementById('ticks');
		t.style.left= this.tick_left + 'px';
		t.style.height= this.view_height + 'px';

		var a = document.getElementById('allpages');
		a.style.left= this.page_margin + 'px';		
		
		// redraw tick bar ticks (annotations don't change if page width remains a constant)
		this.display_annotations();
	}
	
	
	//------------------------------------------------------------------------------------
	viewer_data.prototype.render = function() {
	
		// Render template 	
		var html = ejs.render(this.template, { data: this });
		
		document.getElementById(this.element_id).innerHTML = html;	
	}
	
	//------------------------------------------------------------------------------------
	
	

	// annotations

/*
// target is a URL to a page (canvas)
var a = {
    "@type": "oa:Annotation",
    "motivation": "sc:painting",
    "on": "https://www.biodiversitylibrary.org/page/57913211#xywh=48,470,80,10"
};

// target is a region on a canvas, e.g we can highlight a taxonomic name
// by having "full" as the BHL PageID we can use links made in other databases
var a = {
    "@type": "oa:Annotation",
    "motivation": "sc:painting",
    "on": {
        "@type": "oa:SpecificResource",
        "selector": {
          "@type": "oa:FragmentSelector",
          "value": "xywh=48,470,80,10"
        },
        "full": "https://www.biodiversitylibrary.org/page/57913211"
      }
};
*/

/*
	var a1 = {
		"@type": "oa:Annotation",
		"motivation": "sc:painting",
		"resource": {
			"@type": "cnt:ContentAsText",
			"chars": "scoparia"
		},
		"on": {
			"@type": "oa:SpecificResource",
			"selector": {
				"@type": "oa:FragmentSelector",
				  "value": "xywh=354,1885,153,40"
		   
			},
			"full": "https://www.biodiversitylibrary.org/page/57913211"
		}
	};

	// add annotations then display them
	v.add_annotation(a1);
	
	v.display_annotations();	

*/

	
	</script>
	


</body>
</html>


